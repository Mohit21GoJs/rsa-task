name: 🚀 Continuous Deployment

on:
  push:
    branches:
      - main        # Production deployment
      - develop     # Staging deployment
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      force_deploy:
        description: 'Force deployment even if CI is not passing'
        required: false
        default: false
        type: boolean

concurrency:
  group: deploy-${{ github.ref }}-${{ inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'staging') }}
  cancel-in-progress: false

env:
  NODE_VERSION: '18.x'
  PNPM_VERSION: '8.x'
  TF_VERSION: '1.6.0'

jobs:
  # Determine deployment environment
  setup:
    name: 🔧 Setup Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      should_deploy: ${{ steps.check.outputs.should_deploy }}
    steps:
      - name: Determine environment
        id: env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi

      - name: Check if should deploy
        id: check
        run: |
          if [ "${{ inputs.force_deploy }}" = "true" ]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            # Check if CI passed (this would normally check the latest CI run)
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          fi

  # Infrastructure provisioning
  terraform:
    name: 🏗️ Infrastructure
    runs-on: ubuntu-latest
    needs: [setup]
    if: needs.setup.outputs.should_deploy == 'true'
    environment: ${{ needs.setup.outputs.environment }}
    defaults:
      run:
        working-directory: ./infrastructure
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Terraform Format Check
        run: terraform fmt -check

      - name: Terraform Init
        run: terraform init -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}"

      - name: Terraform Validate
        run: terraform validate

      - name: Terraform Plan
        run: |
          terraform plan \
            -var="environment=${{ needs.setup.outputs.environment }}" \
            -var="render_api_key=${{ secrets.RENDER_API_KEY }}" \
            -var="database_url=${{ secrets.DATABASE_URL }}" \
            -var="temporal_address=${{ secrets.TEMPORAL_ADDRESS }}" \
            -var="gemini_api_key=${{ secrets.GEMINI_API_KEY }}" \
            -out=tfplan

      - name: Terraform Apply
        if: github.event_name != 'pull_request'
        run: terraform apply -auto-approve tfplan

      - name: Save Terraform outputs
        id: tf_outputs
        run: |
          echo "backend_url=$(terraform output -raw backend_url)" >> $GITHUB_OUTPUT
          echo "frontend_url=$(terraform output -raw frontend_url)" >> $GITHUB_OUTPUT

  # Build and deploy backend
  deploy-backend:
    name: 🚀 Deploy Backend
    runs-on: ubuntu-latest
    needs: [setup, terraform]
    if: needs.setup.outputs.should_deploy == 'true'
    environment: ${{ needs.setup.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build backend
        run: pnpm run build:backend

      - name: Deploy to Render
        uses: johnbeynon/render-deploy-action@v0.0.8
        with:
          service-id: ${{ secrets.RENDER_BACKEND_SERVICE_ID }}
          api-key: ${{ secrets.RENDER_API_KEY }}
          wait-for-success: true

  # Build and deploy frontend
  deploy-frontend:
    name: 🚀 Deploy Frontend
    runs-on: ubuntu-latest
    needs: [setup, terraform, deploy-backend]
    if: needs.setup.outputs.should_deploy == 'true'
    environment: ${{ needs.setup.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build frontend
        run: pnpm run build:frontend
        env:
          NEXT_PUBLIC_API_URL: ${{ needs.terraform.outputs.backend_url }}

      - name: Deploy to Render
        uses: johnbeynon/render-deploy-action@v0.0.8
        with:
          service-id: ${{ secrets.RENDER_FRONTEND_SERVICE_ID }}
          api-key: ${{ secrets.RENDER_API_KEY }}
          wait-for-success: true

  # Deploy Temporal worker
  deploy-worker:
    name: 🔄 Deploy Worker
    runs-on: ubuntu-latest
    needs: [setup, terraform, deploy-backend]
    if: needs.setup.outputs.should_deploy == 'true'
    environment: ${{ needs.setup.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy Worker to Render
        uses: johnbeynon/render-deploy-action@v0.0.8
        with:
          service-id: ${{ secrets.RENDER_WORKER_SERVICE_ID }}
          api-key: ${{ secrets.RENDER_API_KEY }}
          wait-for-success: true

  # Health checks and smoke tests
  health-check:
    name: 🏥 Health Check
    runs-on: ubuntu-latest
    needs: [setup, terraform, deploy-backend, deploy-frontend, deploy-worker]
    if: needs.setup.outputs.should_deploy == 'true'
    steps:
      - name: Wait for services to be ready
        run: sleep 30

      - name: Check backend health
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" "${{ needs.terraform.outputs.backend_url }}/api/health" || echo "000")
          if [ "$response" != "200" ]; then
            echo "❌ Backend health check failed with status: $response"
            exit 1
          fi
          echo "✅ Backend is healthy"

      - name: Check frontend health
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" "${{ needs.terraform.outputs.frontend_url }}" || echo "000")
          if [ "$response" != "200" ]; then
            echo "❌ Frontend health check failed with status: $response"
            exit 1
          fi
          echo "✅ Frontend is healthy"

      - name: Run smoke tests
        run: |
          # Basic API endpoint test
          curl -f "${{ needs.terraform.outputs.backend_url }}/api/applications" \
            -H "Content-Type: application/json" \
            -X GET || exit 1
          echo "✅ Smoke tests passed"

  # Notification and rollback
  notify:
    name: 📢 Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [setup, terraform, deploy-backend, deploy-frontend, deploy-worker, health-check]
    if: always() && needs.setup.outputs.should_deploy == 'true'
    steps:
      - name: Determine deployment status
        id: status
        run: |
          if [ "${{ needs.health-check.result }}" = "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=✅ Deployment to ${{ needs.setup.outputs.environment }} completed successfully" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=❌ Deployment to ${{ needs.setup.outputs.environment }} failed" >> $GITHUB_OUTPUT
          fi

      - name: Create deployment status
        uses: actions/github-script@v7
        with:
          script: |
            const { data: deployment } = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: '${{ needs.setup.outputs.environment }}',
              auto_merge: false,
              required_contexts: []
            });

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.id,
              state: '${{ steps.status.outputs.status }}',
              description: '${{ steps.status.outputs.message }}',
              environment_url: '${{ needs.terraform.outputs.frontend_url }}'
            });

      # Placeholder for Slack/Teams notification
      - name: Notify team
        if: always()
        run: |
          echo "🔔 Notification: ${{ steps.status.outputs.message }}"
          echo "Environment: ${{ needs.setup.outputs.environment }}"
          echo "Frontend: ${{ needs.terraform.outputs.frontend_url }}"
          echo "Backend: ${{ needs.terraform.outputs.backend_url }}"
          # Add your notification logic here (Slack, Teams, email, etc.) 